# Functions that are 'exported' by the package (i.e. visible to package users).



#' Remove duplicate columns that are generated by REDCap's data import code
#'
#' REDCap generates R code to import data and label it, which is great. But when it does
#' labels and levels factor columns, it makes a copy of the original column (for example,
#' `original` copied into `original.factor`) that doesn't even have the labels from the
#' original, which is bad.
#'
#' This function:
#'
#' 1. Copies the labels from `original` into `original.factor`,
#' 2. removes `original`,
#' 3. renames `original.factor` to `original`.
#'
#' @param df (Dataframe) A dataframe imported using REDCap's auto-generated R code.
#'
#' @return A dataframe.
#' @export
#'
#' @importFrom magrittr %>%
shrink_redcap_cols <- function(df) {
    # ---- 1. Identify the columns to operate on ----

    # First, identify the columns suffixed with '.factor'.
    suffixed_cols <- stringr::str_subset(colnames(df), "^.*?\\.factor$")

    # Removing the '.factor' suffix *should* give a list of the original columns.
    unsuffixed_cols <- stringr::str_remove_all(suffixed_cols, "\\.factor$")

    # This is the order of columns in the original dataframe, minus the .factor cols.
    # It will be needed for re-ordering the columns at the end.
    col_order <- stringr::str_subset(colnames(df), "^.*?\\.factor$", negate = TRUE)


    # ---- 2. Copy labels from original cols to their copies ----

    # To copy the labels from the original columns into the `.factor` copies, they need to
    # be in separate dataframes and be renamed identically.

    vars_to_keep <-  # Has the .factor cols
        df %>%
        dplyr::select(dplyr::any_of(suffixed_cols)) %>%
        # copy_labels_from() requires the paired columns to have identical names
        dplyr::rename_with(~ stringr::str_remove(., "\\.factor"))

    vars_to_discard <-  # Has the original cols
        df %>%
        # any_of() is always used here for safety, in case some columns don't exist.
        dplyr::select(dplyr::any_of(unsuffixed_cols))

    labelled_suffixed_vars <-  # Has the .factor cols, with labels copied in
        vars_to_keep %>%
        labelled::copy_labels_from(vars_to_discard)

    # ---- 3. Fix and reorder columns ----

    fixed_df <-
        df %>%
        # Delete all of these columns.
        dplyr::select(-dplyr::ends_with(unsuffixed_cols),
                      -dplyr::ends_with(suffixed_cols)) %>%
        # Bind the new labelled and renamed columns back in.
        dplyr::bind_cols(labelled_suffixed_vars) %>%
        # Re-sort the variable names back to their original order.
        dplyr::relocate(dplyr::any_of(col_order), dplyr::everything())


    all_cols_present <- all(unsuffixed_cols %in% colnames(fixed_df))

    if (all_cols_present) {
        return(fixed_df)
    } else {
        stop("The resulting dataframe is missing some of the expected columns.",
             "\n",
             "The missing columns are:",
             "\n",
             desiderata::fold(unsuffixed_cols[!unsuffixed_cols %in% colnames(fixed_df)],
                              n = Inf))
    }
}



#' Copy factor levels, ordering, and labels from one vector to another
#'
#' This function supports vectors that were labelled with either [Hmisc::label()] or
#' [haven::labelled()].
#'
#' @param to (Vector) The vector to be factored and labelled.
#' @param from (Vector) The vector whose factor levels and labels will be used.
#' @param ... (...) Additional arguments that will be passed to [factor()].
#'
#' @details Labels will only be applied to `to` if they existed in `from`.
#'
#' @return A factorised version of `to` with levels, level ordering, and labels (if any).
#' @export
#'
#' @examples
#' # ---- Labelled with Hmisc ----
#'
#' fac_old_ord <-
#'     ordered(c("Always", "Sometimes", "Always", "Rarely",
#'               "Never", "Sometimes", "Rarely", "Never"),
#'             levels = c("Always", "Sometimes", "Rarely", "Never"))
#'
#' Hmisc::label(fac_old_ord) <- "This label is for my ordered and labelled factor."
#'
#' fac_new_ord <- c("Rarely", "Always", "Sometimes", "Never",
#'                  "Never", "Always", "Rarely")
#'
#'
#' # This copies the levels, ordering, and label from `fac_old_ord` to `fac_new_ord`.
#' copy_definition(fac_new_ord, fac_old_ord)
#'
#' #> An example of an ordered and labelled factor.
#' #> [1] Rarely    Always    Sometimes Never     Never     Always    Rarely
#' #> [8] Sometimes
#' #> Levels: Always < Sometimes < Rarely < Never
#'
#'
#'
#' # ---- Labelled with haven ----
#'
#' haven_old <- haven::labelled(c("M", "M", "F"),
#'                              c(Male = "M", Female = "F"),
#'                              "This label is for my haven-labelled factor.")
#'
#' haven_new <- c("M", "F", "F", "F", "M")
#'
#'
#' copy_definition(haven_new, haven_old)
#'
#' #> <labelled<character>[5]>: This label is for my haven-labelled factor.
#' #> [1] M F F F M
#' #>
#' #> Labels:
#' #>     value  label
#' #> M   Male
#' #> F Female
#'
#'
#'
#' # ---- Unlabelled ----
#'
#' fac_old_unord <-
#'     factor(c("Curtain", "Cat", "Keyboard",
#'              "Keyboard", "Cat", "Curtain"))
#'
#' fac_new_unord <- c("Curtain", "Keyboard", "Curtain",
#'                    "Cat", "Cat", "Keyboard")
#'
#'
#' # Since `fac_old_unord` was unlabelled, the output is also unlabelled.
#' copy_definition(fac_new_unord, fac_old_unord)
#'
#' #> [1] Curtain  Keyboard Curtain  Cat      Cat      Keyboard
#' #> Levels: Cat Curtain Keyboard
#'
copy_definition <- function(to, from, ...) {
    # Haven labelling. It's handled first because haven::labelled() expects x and
    # labels to be of the same type. But factors in R are actually Integers, so trying
    # to label a factor vector with a Character vector gives the error:
    # #> Can't convert `labels` <character> to match type of `x` <integer>.
    if ("haven_labelled" %in% class(from)) {
        out <- haven::labelled(x = to,
                               labels = attr(from, "labels"),
                               label = attr(from, "label"))

        return(out)
    }

    # Only turn `to` into a factor if `from` is one to begin with.
    if (is.factor(from)) {
        out <- factor(x = to,
                      levels = levels(from),
                      ordered = is.ordered(from),
                      ...)
    } else {
        out <- to
    }


    # Only apply a label to the new vector if one existed in the old one.
    # This is because labelling adds the "labelled" class to the vector as well,
    # which some functions (e.g. skimr::skim()) do not know how to handle.
    if ("labelled" %in% class(from)) {
        Hmisc::label(out) <- Hmisc::label(from)
    } else if (is.null(attributes(from)$label) == FALSE) {
        # labelled package does not change the vector's class, but it does add a 'label'
        # attribute to the vector.
        attr(out, "label") <-  attr(from, "label")
    }

    return(out)
}



#' One-step evaluation and labelling
#'
#' @param expr (Expression) An expression to evaluate.
#' @param label (Character) The label to apply to the output.
#'
#' @return The evaluated result of `expr`, labelled with `label`.
#' @export
#'
#' @examples
#' with_label(1:10 < 5,
#'            "This number is smaller than 5.")
#'
#' #> This number is smaller than 5.
#' #> [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
#'
#' add_to_iris <-
#'     iris |>
#'     dplyr::mutate(is_setosa = with_label(Species == "setosa",
#'                                          "This is an I. setosa record."))
#'
#' str(add_to_iris$is_setosa)
#'
#' #> labelled' logi [1:150] TRUE TRUE TRUE TRUE TRUE TRUE ...
#' #> - attr(*, "label")= chr "This is an I. setosa record."
#'
#' # You can also pipe into with_label()
#' 1:10 |> with_label("A vector of 10 numbers.") |> str()
#'
#' #> labelled' int [1:10] 1 2 3 4 5 6 7 8 9 10
#' #> - attr(*, "label")= chr "A vector of 10 numbers."
#'
with_label <- function(expr, label) {
    out <- eval(expr)

    # attr(out, "label") <- label
    Hmisc::label(out) <- label

    return(out)
}



#' Copy labels between dataframes
#'
#' This uses [Hmisc::label<-()] to apply labels to the dataframe. Dataframes that were
#' labelled by [Hmisc::label()], [haven::labelled()], or [labelled::var_label()] are
#' accepted.
#'
#' Value labels are also copied over.
#'
#' @param to (Dataframe) The dataframe whose columns will be labelled.
#' @param from (Dataframe) The dataframe whose labels will be used.
#'
#' @details Column names must exactly match between `to` and `from`. Columns in `to` that
#' are not in `from` will not be modified.
#'
#' @return A version of `to` with variables labelled. Since `Hmisc` is used
#' to do the labelling, it also adds the `labelled` class to the vector.
#'
#' @export
#'
#' @examples
#' x <- copy_dataframe_labels(iris, iris_labelled_hmisc)
#' str(x)
#'
#' ## data.frame':	150 obs. of  5 variables:
#' ##     $ Sepal.Length: 'labelled' num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
#' ## ..- attr(*, "label")= chr "Length of sepals."
#' ## $ Sepal.Width : 'labelled' num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
#' ## ..- attr(*, "label")= chr "Width of sepals."
#' ## $ Petal.Length: 'labelled' num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
#' ## ..- attr(*, "label")= chr "Length of petals."
#' ## $ Petal.Width : 'labelled' num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
#' ## ..- attr(*, "label")= chr "Width of petals."
#' ## $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1  ...
#' ## ..- attr(*, "label")= chr "Species of iris: setosa, versicolor, virginica"
#'
copy_dataframe_labels <- function(to, from) {
    cols_to_label <- desiderata::same_cols(to, from)

    # Code writing code! :3
    for (i in cols_to_label) {
        # The variable's label
        has_label <-
            eval(parse(text = glue::glue("is.null(attr(from${i}, 'label')) == FALSE")))

        # Labels applied to the variable's values (by haven, usually).
        has_value_labels <-
            eval(parse(text = glue::glue("is.null(attr(from${i}, 'labels')) == FALSE")))

        # "Evaluate expression given as a string"
        # https://stackoverflow.com/a/1743796/5578429

        if (has_label) {
            # Hmisc::label(to$colname) <- attr(from$colname, 'label')
            code_label <-
                glue::glue("Hmisc::label(to${i}) <- attr(from${i}, 'label')")

            eval(parse(text = code_label))
        }

        if (has_value_labels) {
            # attr(to$colname, 'labels') <- attr(from$colname, 'labels')
            code_value_labels <-
                glue::glue("attr(to${i}, 'labels') <- attr(from${i}, 'labels')")

            eval(parse(text = code_value_labels))
        }
    }

    return(to)
}
