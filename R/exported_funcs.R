# Functions that are 'exported' by the package (i.e. visible to package users).



#' Remove duplicate columns that are generated by REDCap's data import code
#'
#' REDCap generates R code to import data and label it, which is great. But when it does
#' labels and levels factor columns, it makes a copy of the original column (for example,
#' `original` copied into `original.factor`) that doesn't even have the labels from the
#' original, which is bad.
#'
#' This function:
#'
#' 1. Copies the labels from `original` into `original.factor`,
#' 2. removes `original`,
#' 3. renames `original.factor` to `original`.
#'
#' @param df (Dataframe) A dataframe imported using REDCap's auto-generated R code.
#'
#' @return A dataframe.
#' @export
#'
#' @importFrom magrittr %>%
shrink_redcap_cols <- function(df) {
    # ---- 1. Identify the columns to operate on ----

    # First, identify the columns suffixed with '.factor'.
    suffixed_cols <- stringr::str_subset(colnames(df), "^.*?\\.factor$")

    # Removing the '.factor' suffix *should* give a list of the original columns.
    unsuffixed_cols <- stringr::str_remove_all(suffixed_cols, "\\.factor$")

    # This is the order of columns in the original dataframe, minus the .factor cols.
    # It will be needed for re-ordering the columns at the end.
    col_order <- stringr::str_subset(colnames(df), "^.*?\\.factor$", negate = TRUE)


    # ---- 2. Copy labels from original cols to their copies ----

    # To copy the labels from the original columns into the `.factor` copies, they need to
    # be in separate dataframes and be renamed identically.

    vars_to_keep <-  # Has the .factor cols
        df %>%
        dplyr::select(dplyr::any_of(suffixed_cols)) %>%
        # copy_labels_from() requires the paired columns to have identical names
        dplyr::rename_with(~ stringr::str_remove(., "\\.factor"))

    vars_to_discard <-  # Has the original cols
        df %>%
        # any_of() is always used here for safety, in case some columns don't exist.
        dplyr::select(dplyr::any_of(unsuffixed_cols))

    labelled_suffixed_vars <-  # Has the .factor cols, with labels copied in
        vars_to_keep %>%
        labelled::copy_labels_from(vars_to_discard)

    # ---- 3. Fix and reorder columns ----

    fixed_df <-
        df %>%
        # Delete all of these columns.
        dplyr::select(-dplyr::ends_with(unsuffixed_cols),
                      -dplyr::ends_with(suffixed_cols)) %>%
        # Bind the new labelled and renamed columns back in.
        dplyr::bind_cols(labelled_suffixed_vars) %>%
        # Re-sort the variable names back to their original order.
        dplyr::relocate(dplyr::any_of(col_order), dplyr::everything())


    all_cols_present <- all(unsuffixed_cols %in% colnames(fixed_df))

    if (all_cols_present) {
        return(fixed_df)
    } else {
        stop("The resulting dataframe is missing some of the expected columns.",
             "\n",
             "The missing columns are:",
             "\n",
             stringr::str_flatten_comma(unsuffixed_cols[!unsuffixed_cols %in% colnames(fixed_df)],
                                        last = ", and "))
    }
}



#' Copy factor levels, ordering, and labels from one vector to another
#'
#' This function supports vectors that were labelled with either [Hmisc::label()] or
#' [haven::labelled()].
#'
#' @param to (Vector) The vector to be factored and labelled.
#' @param from (Vector) The vector whose factor levels and labels will be used.
#' @param ... (...) Additional arguments that will be passed to [factor()].
#'
#' @details Labels will only be applied to `to` if they existed in `from`.
#'
#' @return A factorised version of `to` with levels, level ordering, and labels (if any).
#' @export
#'
#' @examples
#' # ---- Labelled with Hmisc ----
#'
#' fac_old_ord <-
#'     ordered(c("Always", "Sometimes", "Always", "Rarely",
#'               "Never", "Sometimes", "Rarely", "Never"),
#'             levels = c("Always", "Sometimes", "Rarely", "Never"))
#'
#' Hmisc::label(fac_old_ord) <- "This label is for my ordered and labelled factor."
#'
#' fac_new_ord <- c("Rarely", "Always", "Sometimes", "Never",
#'                  "Never", "Always", "Rarely")
#'
#'
#' # This copies the levels, ordering, and label from `fac_old_ord` to `fac_new_ord`.
#' copy_definition(fac_new_ord, fac_old_ord)
#'
#' #> An example of an ordered and labelled factor.
#' #> [1] Rarely    Always    Sometimes Never     Never     Always    Rarely
#' #> [8] Sometimes
#' #> Levels: Always < Sometimes < Rarely < Never
#'
#'
#'
#' # ---- Labelled with haven ----
#'
#' haven_old <- haven::labelled(c("M", "M", "F"),
#'                              c(Male = "M", Female = "F"),
#'                              "This label is for my haven-labelled factor.")
#'
#' haven_new <- c("M", "F", "F", "F", "M")
#'
#'
#' copy_definition(haven_new, haven_old)
#'
#' #> <labelled<character>[5]>: This label is for my haven-labelled factor.
#' #> [1] M F F F M
#' #>
#' #> Labels:
#' #>     value  label
#' #> M   Male
#' #> F Female
#'
#'
#'
#' # ---- Unlabelled ----
#'
#' fac_old_unord <-
#'     factor(c("Curtain", "Cat", "Keyboard",
#'              "Keyboard", "Cat", "Curtain"))
#'
#' fac_new_unord <- c("Curtain", "Keyboard", "Curtain",
#'                    "Cat", "Cat", "Keyboard")
#'
#'
#' # Since `fac_old_unord` was unlabelled, the output is also unlabelled.
#' copy_definition(fac_new_unord, fac_old_unord)
#'
#' #> [1] Curtain  Keyboard Curtain  Cat      Cat      Keyboard
#' #> Levels: Cat Curtain Keyboard
#'
copy_definition <- function(to, from, ...) {
    # Haven labelling. It's handled first because haven::labelled() expects x and
    # labels to be of the same type. But factors in R are actually Integers, so trying
    # to label a factor vector with a Character vector gives the error:
    # #> Can't convert `labels` <character> to match type of `x` <integer>.
    if ("haven_labelled" %in% class(from)) {
        out <- haven::labelled(x = to,
                               labels = attr(from, "labels"),
                               label = attr(from, "label"))

        return(out)
    }

    # Only turn `to` into a factor if `from` is one to begin with.
    if (is.factor(from)) {
        out <- factor(x = to,
                      levels = levels(from),
                      ordered = is.ordered(from),
                      ...)
    } else {
        out <- to
    }


    # Only apply a label to the new vector if one existed in the old one.
    # This is because labelling adds the "labelled" class to the vector as well,
    # which some functions (e.g. skimr::skim()) do not know how to handle.
    if ("labelled" %in% class(from)) {
        Hmisc::label(out) <- Hmisc::label(from)
    } else if (is.null(attributes(from)$label) == FALSE) {
        # labelled package does not change the vector's class, but it does add a 'label'
        # attribute to the vector.
        attr(out, "label") <-  attr(from, "label")
    }

    return(out)
}



#' One-step evaluation and labelling
#'
#' @param expr (Expression) An expression to evaluate.
#' @param label (Character) The label to apply to the output.
#'
#' @return The evaluated result of `expr`, labelled with `label`.
#' @export
#'
#' @examples
#' with_label(1:10 < 5,
#'            "This number is smaller than 5.")
#'
#' #> This number is smaller than 5.
#' #> [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
#'
#' add_to_iris <-
#'     iris |>
#'     dplyr::mutate(is_setosa = with_label(Species == "setosa",
#'                                          "This is an I. setosa record."))
#'
#' str(add_to_iris$is_setosa)
#'
#' #> labelled' logi [1:150] TRUE TRUE TRUE TRUE TRUE TRUE ...
#' #> - attr(*, "label")= chr "This is an I. setosa record."
#'
#' # You can also pipe into with_label()
#' 1:10 |> with_label("A vector of 10 numbers.") |> str()
#'
#' #> labelled' int [1:10] 1 2 3 4 5 6 7 8 9 10
#' #> - attr(*, "label")= chr "A vector of 10 numbers."
#'
with_label <- function(expr, label) {
    out <- eval(expr)

    # attr(out, "label") <- label
    Hmisc::label(out) <- label

    return(out)
}



#' Copy labels between dataframes
#'
#' This uses [Hmisc::label<-()] to apply labels to the dataframe. Dataframes that were
#' labelled by [Hmisc::label()], [haven::labelled()], or [labelled::var_label()] are
#' accepted.
#'
#' Value labels are also copied over.
#'
#' @param to (Dataframe) The dataframe whose columns will be labelled.
#' @param from (Dataframe) The dataframe whose labels will be used.
#'
#' @details Column names must exactly match between `to` and `from`. Columns in `to` that
#' are not in `from` will not be modified.
#'
#' @return A version of `to` with variables labelled. Since `Hmisc` is used
#' to do the labelling, it also adds the `labelled` class to the vector.
#'
#' @export
#'
#' @examples
#' x <- copy_dataframe_labels(iris, iris_labelled_hmisc)
#' str(x)
#'
#' ## data.frame':	150 obs. of  5 variables:
#' ##     $ Sepal.Length: 'labelled' num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
#' ## ..- attr(*, "label")= chr "Length of sepals."
#' ## $ Sepal.Width : 'labelled' num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
#' ## ..- attr(*, "label")= chr "Width of sepals."
#' ## $ Petal.Length: 'labelled' num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
#' ## ..- attr(*, "label")= chr "Length of petals."
#' ## $ Petal.Width : 'labelled' num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
#' ## ..- attr(*, "label")= chr "Width of petals."
#' ## $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1  ...
#' ## ..- attr(*, "label")= chr "Species of iris: setosa, versicolor, virginica"
#'
copy_dataframe_labels <- function(to, from) {
    cols_to_label <- base::intersect(colnames(to), colnames(from))

    # Code writing code! :3
    for (i in cols_to_label) {
        # The variable's label
        has_label <-
            eval(parse(text = glue::glue("is.null(attr(from${i}, 'label')) == FALSE")))

        # Labels applied to the variable's values (by haven, usually).
        has_value_labels <-
            eval(parse(text = glue::glue("is.null(attr(from${i}, 'labels')) == FALSE")))

        # "Evaluate expression given as a string"
        # https://stackoverflow.com/a/1743796/5578429

        if (has_label) {
            # Hmisc::label(to$colname) <- attr(from$colname, 'label')
            code_label <-
                glue::glue("Hmisc::label(to${i}) <- attr(from${i}, 'label')")

            eval(parse(text = code_label))
        }

        if (has_value_labels) {
            # attr(to$colname, 'labels') <- attr(from$colname, 'labels')
            code_value_labels <-
                glue::glue("attr(to${i}, 'labels') <- attr(from${i}, 'labels')")

            eval(parse(text = code_value_labels))
        }
    }

    return(to)
}


#' Fuzzily search column names and labels
#'
#' When working with dataframes hundreds of columns wide, it can be hard to find which
#' variable contains a particular measurement. This function lets you fuzzily search a
#' dataframe's column names and labels (the `attr()` named `"label"`) for a match. It also
#' reports appropriate summary statistics like:
#'
#' - Variable type
#' - Number of unique elements
#' - Percentage of the vector that is `NA` or `NaN`
#' - Range (min to max)
#' - Mode (most common value(s))
#' - Median (50th percentile value)
#'
#' @param df (Dataframe) The dataframe
#' @param query (Character) A string (or regular expression) to search for.
#' @param dist (Numeric) Maximum string distance. Either an integer or a double; see
#'     `max.distance` in `base::agrep()`. Set to `0` to force an exact match.
#'
#' @return Prints out matching name & label combinations, and invisibly returns the same.
#' @export
#'
#' @examples
#'
#' sift(iris_labelled_hmisc, "pal.width")
#' # Note fuzzy searching gets both "pal.width" and "tal.width"
#'
#' #> Sepal.Width | type: numeric | Uniq: 23 | NA %: 0
#' #>     Width of sepals.
#' #>     range: 2-4.4 | mode: 3 | median: 3
#' #> Petal.Width | type: numeric | Uniq: 22 | NA %: 0
#' #>     Width of petals.
#' #>     range: 0.1-2.5 | mode: 0.2 | median: 1.3
#'
#' sift(iris_labelled_hmisc, "pal.width", dist = 0)
#' # dist = 0 forces an exact match
#'
#' #> Sepal.Width | type: numeric | Uniq: 23 | NA %: 0
#' #>     Width of sepals.
#' #>     range: 2-4.4 | mode: 3 | median: 3
#'
#' sift(iris_labelled_hmisc, "versicol")
#' # The columns' labels are also searched.
#'
#' #> Species | type: factor | Uniq: 3 | NA %: 0
#' #>     Species of iris: setosa, versicolor, virginica
#' #>     mode: setosa, versicolor, and 1 other
#'
#' @section Authors:
#' - Desi Quintans (<http://www.desiquintans.com>)
#' @md
#' @importFrom magrittr %>%
sift <- function(df, query, dist = 0.1) {
    get_label <- function(item) {
        result <- attr(item, "label")

        if (is.null(result)) {
            return("")
        } else {
            return(stringr::str_trim(result))
        }
    }

    fold <- function(vec, n = 2) {
        if (length(vec) >= n) {
            # Need to truncate the vector and show remainder.
            paste(
                stringr::str_flatten_comma(vec[1:n]),
                "and", length(vec) - n, "others"
            )
        } else {
            # Whole vector can be shown.
            stringr::str_flatten_comma(vec)
        }
    }

    round_to <- function(x, digits = 2) {
        nums_as_char <- trimws(format(round(x, digits = digits), nsmall = digits))
        as.numeric(nums_as_char)
    }

    Mode <- function(x, na.rm = FALSE) {
        if (na.rm) {
            x = x[!is.na(x)]
        }

        ux <- unique(x)
        tab <- tabulate(match(x, ux))
        result <- ux[tab == max(tab)]

        return(result)
    }

    attr_name  <- stringr::str_trim(colnames(df))
    attr_label <- sapply(df, get_label, USE.NAMES = FALSE)
    names(attr_label) <- NULL

    # This is what gets searched to find matching columns
    attr_joined <- stringr::str_trim(paste(attr_name, attr_label))

    out <- agrep(query, attr_joined, ignore.case = TRUE, value = FALSE, fixed = FALSE,
                 max.distance = dist)

    purrr::pwalk(list(attr_name[out], attr_label[out], df[out]),
                 function(colname, lab, vec) {


                     cli::cli({
                         cli::cli_text(colname,
                                       cli::col_silver(
                                           glue::glue(
                                               "",
                                               "type: {fold(class(vec), 2)}",
                                               "Uniq: {length(unique(vec))}",
                                               "NA %: {round_to(sum(is.na(vec))/length(vec)*100)}",
                                               .sep = " | "
                                           )
                                       )
                         )

                         cli::cli_div(class = "tmp",
                                      theme = list(.tmp = list("margin-left" = 4,
                                                               "margin-right" = 4)))
                         if (lab != "") {
                             cli::cli_text(cli::col_silver(lab))
                         }

                         if (is.numeric(vec)) {
                             cli::cli_text(cli::col_silver(
                                 glue::glue("range: {paste(round_to(range(vec, na.rm = TRUE)), collapse = '-')}",
                                            "mode: {fold(Mode(vec, na.rm = TRUE))}",
                                            "median: {round_to(median(vec, na.rm = TRUE))}",
                                            .sep = " | "
                                 )
                             ))
                         } else {
                             cli::cli_text(cli::col_silver(
                                 glue::glue("mode: {fold(Mode(vec, na.rm = TRUE))}",
                                            .sep = " | "
                                 )
                             ))
                         }
                     })
                 }
    )

    return(invisible(list(cols = attr_name[out],
                          labels = attr_label[out])))
}
