# Functions that are 'exported' by the package (i.e. visible to package users).



#' Remove duplicate columns that are generated by REDCap's data import code
#'
#' REDCap generates R code to import data and label it, which is great. But when it does
#' labels and levels factor columns, it makes a copy of the original column (for example,
#' `original` copied into `original.factor`) that doesn't even have the labels from the
#' original, which is bad.
#'
#' This function:
#'
#' 1. Copies the labels from `original` into `original.factor`,
#' 2. removes `original`,
#' 3. renames `original.factor` to `original`.
#'
#' @param df (Dataframe) A dataframe imported using REDCap's auto-generated R code.
#'
#' @return A dataframe.
#' @export
#'
#' @importFrom magrittr %>%
shrink_redcap_cols <- function(df) {
    # ---- 1. Identify the columns to operate on ----

    # First, identify the columns suffixed with '.factor'.
    suffixed_cols <- stringr::str_subset(colnames(df), "^.*?\\.factor$")

    # Removing the '.factor' suffix *should* give a list of the original columns.
    unsuffixed_cols <- stringr::str_remove_all(suffixed_cols, "\\.factor$")

    # This is the order of columns in the original dataframe, minus the .factor cols.
    # It will be needed for re-ordering the columns at the end.
    col_order <- stringr::str_subset(colnames(df), "^.*?\\.factor$", negate = TRUE)


    # ---- 2. Copy labels from original cols to their copies ----

    # To copy the labels from the original columns into the `.factor` copies, they need to
    # be in separate dataframes and be renamed identically.

    vars_to_keep <-  # Has the .factor cols
        df %>%
        dplyr::select(dplyr::any_of(suffixed_cols)) %>%
        # copy_labels_from() requires the paired columns to have identical names
        dplyr::rename_with(~ stringr::str_remove(., "\\.factor"))

    vars_to_discard <-  # Has the original cols
        df %>%
        # any_of() is always used here for safety, in case some columns don't exist.
        dplyr::select(dplyr::any_of(unsuffixed_cols))

    labelled_suffixed_vars <-  # Has the .factor cols, with labels copied in
        vars_to_keep %>%
        labelled::copy_labels_from(vars_to_discard)

    # ---- 3. Fix and reorder columns ----

    fixed_df <-
        df %>%
        # Delete all of these columns.
        dplyr::select(-dplyr::ends_with(unsuffixed_cols),
                      -dplyr::ends_with(suffixed_cols)) %>%
        # Bind the new labelled and renamed columns back in.
        dplyr::bind_cols(labelled_suffixed_vars) %>%
        # Re-sort the variable names back to their original order.
        dplyr::relocate(dplyr::any_of(col_order), dplyr::everything())


    all_cols_present <- all(unsuffixed_cols %in% colnames(fixed_df))

    if (all_cols_present) {
        return(fixed_df)
    } else {
        stop("The resulting dataframe is missing some of the expected columns.",
             "\n",
             "The missing columns are:",
             "\n",
             desiderata::fold(unsuffixed_cols[!unsuffixed_cols %in% colnames(fixed_df)],
                              n = Inf))
    }
}



#' Copy factor levels, ordering, and labels from one vector to another
#'
#' This function supports vectors that were labelled with either [Hmisc::label()] or
#' [haven::labelled()].
#'
#' @param to (Vector) The vector to be factored and labelled.
#' @param from (Vector) The vector whose factor levels and labels will be used.
#' @param ... (...) Additional arguments that will be passed to [factor()].
#'
#' @details Labels will only be applied to `to` if they existed in `from`.
#'
#' @return A factorised version of `to` with levels, level ordering, and labels (if any).
#' @export
#'
#' @examples
#' # ---- Labelled with Hmisc ----
#'
#' fac_old_ord <-
#'     ordered(c("Always", "Sometimes", "Always", "Rarely",
#'               "Never", "Sometimes", "Rarely", "Never"),
#'             levels = c("Always", "Sometimes", "Rarely", "Never"))
#'
#' Hmisc::label(fac_old_ord) <- "This label is for my ordered and labelled factor."
#'
#' fac_new_ord <- c("Rarely", "Always", "Sometimes", "Never",
#'                  "Never", "Always", "Rarely")
#'
#'
#' # This copies the levels, ordering, and label from `fac_old_ord` to `fac_new_ord`.
#' copy_definition(fac_new_ord, fac_old_ord)
#'
#' #> An example of an ordered and labelled factor.
#' #> [1] Rarely    Always    Sometimes Never     Never     Always    Rarely
#' #> [8] Sometimes
#' #> Levels: Always < Sometimes < Rarely < Never
#'
#'
#'
#' # ---- Labelled with haven ----
#'
#' haven_old <- haven::labelled(c("M", "M", "F"),
#'                              c(Male = "M", Female = "F"),
#'                              "This label is for my haven-labelled factor.")
#'
#' haven_new <- c("M", "F", "F", "F", "M")
#'
#'
#' copy_definition(haven_new, haven_old)
#'
#' #> <labelled<character>[5]>: This label is for my haven-labelled factor.
#' #> [1] M F F F M
#' #>
#' #> Labels:
#' #>     value  label
#' #> M   Male
#' #> F Female
#'
#'
#'
#' # ---- Unlabelled ----
#'
#' fac_old_unord <-
#'     factor(c("Curtain", "Cat", "Keyboard",
#'              "Keyboard", "Cat", "Curtain"))
#'
#' fac_new_unord <- c("Curtain", "Keyboard", "Curtain",
#'                    "Cat", "Cat", "Keyboard")
#'
#'
#' # Since `fac_old_unord` was unlabelled, the output is also unlabelled.
#' copy_definition(fac_new_unord, fac_old_unord)
#'
#' #> [1] Curtain  Keyboard Curtain  Cat      Cat      Keyboard
#' #> Levels: Cat Curtain Keyboard
#'
copy_definition <- function(to, from, ...) {
    # Haven labelling. It's handled first because haven::labelled() expects x and
    # labels to be of the same type. But factors in R are actually Integers, so trying
    # to label a factor vector with a Character vector gives the error:
    # #> Can't convert `labels` <character> to match type of `x` <integer>.
    if ("haven_labelled" %in% class(from)) {
        out <- haven::labelled(x = to,
                               labels = attr(from, "labels"),
                               label = attr(from, "label"))

        return(out)
    }

    out <- factor(x = to,
                  levels = levels(from),
                  ordered = is.ordered(from),
                  ...)

    # Only apply a label to the new vector if one existed in the old one.
    # This is because labelling adds the "labelled" class to the vector as well,
    # which some functions (e.g. skimr::skim()) do not know how to handle.
    if ("labelled" %in% class(from)) {
        Hmisc::label(out) <- Hmisc::label(from)
    }

    return(out)
}



#' One-step evaluation and labelling with Hmisc
#'
#' Labelling with [Hmisc::label()] takes two steps that can't be pipelined. This function
#' does them both.
#'
#' @param expr (Expression) An expression to evaluate.
#' @param label (Character) The label to apply to the output.
#'
#' @return The evaluated result of `expr`, labelled with `label`.
#' @export
#'
#' @examples
#' with_label(1:10 < 5,
#'            "This number is smaller than 5.")
#'
#' #> This number is smaller than 5.
#' #> [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
#'
#' add_to_iris <-
#'     iris |>
#'     dplyr::mutate(is_setosa = with_label(Species == "setosa",
#'                                          "This is an I. setosa record."))
#'
#' str(add_to_iris$is_setosa)
#'
#' #> labelled' logi [1:150] TRUE TRUE TRUE TRUE TRUE TRUE ...
#' #> - attr(*, "label")= chr "This is an I. setosa record."
#'
#' # You can also pipe into with_label()
#' 1:10 |> with_label("A vector of 10 numbers.") |> str()
#'
#' #> labelled' int [1:10] 1 2 3 4 5 6 7 8 9 10
#' #> - attr(*, "label")= chr "A vector of 10 numbers."
#'
with_label <- function(expr, label) {
    out <- eval(expr)

    Hmisc::label(out) <- label

    return(out)
}

